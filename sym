#!/usr/bin/env python

import os
import os.path as path  # for better readability
import sys
import argparse
from fnmatch import fnmatch

# these globs are case-insensitively matched against the filename
# TODO: tests for verbose output (ignored reports)
# TODO: support repeatable --ignore filename (or filepath?) regexes
DEFAULT_GLOB_BLACKLIST = (
    ".git",
    ".gitignore",
    "README*",
    "LICENSE*",
)

def log(msg, v):
    if not v:
        return
    print(msg)

def walk(start, verbose=False):
    with os.scandir(start) as it:
        for entry in it:
            if any(
                fnmatch(path.basename(entry.path), glob)
                for glob in DEFAULT_GLOB_BLACKLIST
            ):
                log(f"IGNORE: {entry.path}", verbose)
                continue
            if entry.is_dir():
                yield from walk(entry.path, verbose)
            elif entry.is_file(follow_symlinks=False):
                yield entry.path


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('source', type=str, nargs='+', help='source directory containing files to be symlinked')
    parser.add_argument('-t', '--target', metavar='TARGET', type=str, help='target directory to create symlinks in (default: $HOME)', default=path.expanduser('~'))
    parser.add_argument('-d', '--delete', action='store_true', help='remove symlinks instead of create')
    parser.add_argument('-p', '--pretend', action='store_true', help='pretend; implies -v but does not perform any actual operations.')
    parser.add_argument('-v', '--verbose', action='store_true', help='print symlinks as they are created or removed')
    args = parser.parse_args()

    source_dirs = []
    for source_dir in args.source:
        if not path.isdir(source_dir):
            sys.exit(f"source directory {source_dir} is not a directory or does not exist")
        if not source_dir.endswith('/'):
            source_dir += '/'
        source_dirs.append(source_dir)

    if not path.isdir(args.target):
        sys.exit(f"target directory {args.target} is not a directory or does not exist")
    target_dir = args.target

    verbose = args.verbose or args.pretend

    # pass #1: collect symlink jobs from all sources and detect conflicts
    # TODO: should symlinks be a set to prevent duplicates?
    symlinks, conflicts = [], []
    for source_dir in source_dirs:
        for filepath in walk(source_dir, verbose):
            '''
            say we're given dotfiles/mpv as a source directory, and it contains .config/mpv/mpv.conf
            say we have a target dir of ~, and dotfiles/mpv full path is ~/somewhere/dotfiles/mpv
            (the $PWD is ~/somewhere)
            we want to create the relative symlink at (the name/path) ~/.config/mpv/mpv.conf,
            pointing to ../../../somewhere/dotfiles/.config/mpv/mpv.conf
            '''
            # the symlink name is target dir + filepath without the parent source_dir
            # XXX: lstrip not ideal, but i don't intend on supporting non-UNIX style paths anyways
            name = path.join(target_dir, filepath.lstrip(source_dir))
            # the symlink dest is filepath, relative to the name's directory.
            # conversion to absolute paths is necessary for relpath to work here.
            dest_abspath = path.abspath(filepath)
            dest = path.relpath(dest_abspath, path.dirname(path.abspath(name)))

            exists = path.exists(name)
            islink = path.islink(name)
            realpath = path.realpath(name)

            if not args.delete:
                # if the symlink we are trying to create exists...
                if exists:
                    # ...but is a symlink to the valid file we are trying to symlink, ignore it.
                    if islink and (realpath == dest_abspath):
                        continue
                    # otherwise, conflict.
                    conflicts.append(f'{name} already exists. sym cannot create symlinks if there is an existing file.')
                    continue
            else:
                # if the symlink doesn't exist, we obviously don't need to try and delete it.
                if not exists:
                    continue
                # but if it does, there is potential for conflicts (deleting something we shouldn't be deleting)
                if not islink:
                    conflicts.append(f'{name} is not a symlink, so refusing to remove.')
                    continue
                if os.readlink(name)[0] == '/':
                    conflicts.append(f'{name} is an absolute symlink. sym only creates relative symlinks, so refusing to remove.')
                    continue
                if realpath != dest_abspath:
                    conflicts.append(f'{name} is a relative symlink, but resolves to {realpath} instead of the expected {dest_abspath}, so refusing to remove.')
                    continue
            symlinks.append((name, dest))

    # if any conflicts, report them and exit
    for c in conflicts:
        print('CONFLICT:', c, file=sys.stderr)
    if conflicts and not args.pretend:
        sys.exit('sym will not start until all conflicts are resolved.')

    if args.pretend:
        # XXX: this doesn't include RMDIR because that depends on actual filesystem operations at the moment
        #      and pretend-specific code to autodetect those operations isn't worth the added complexity right now
        print('Pretend mode is on; the following operations are what would have been executed.')

    # pass #2: perform operations
    if not args.delete:
        for name, dest in symlinks:
            # ensure accomodating directory exists for the new symlink
            name_dir = path.dirname(name)
            if not path.isdir(name_dir):
                if not args.pretend:
                    os.makedirs(name_dir, exist_ok=True)
                log(f'MKDIRS: {name_dir}', verbose)
            # create the symlink
            if not args.pretend:
                os.symlink(dest, name)
            log(f'LINK: {name} -> {dest}', verbose)
    else:
        for name, _ in symlinks:
            # remove the symlink
            if not args.pretend:
                os.unlink(name)
            log(f'UNLINK: {name}', verbose)
            # cleanup as many empty parent dirs as possible
            name_dir = path.dirname(name)
            while not os.listdir(name_dir):
                if not args.pretend:
                    os.rmdir(name_dir)
                log(f'RMDIR: {name_dir}', verbose)
                name_dir = path.dirname(name_dir)  # this is safe because this is a calculation; not dependent on filesystem state
